#!/usr/bin/env bash
# Wrapper for cargo -Zscript with nix, tries --offline first
# Usage: nix-run-cached <script.rs> [args...]
# Tracks script usage and cleans up old caches (>30 days unused)
# Caches the nix store path to avoid re-evaluating the flake expression every time

SCRIPT="$1"
shift

CARGO_TARGET_DIR="${CARGO_TARGET_DIR:-$HOME/.cargo/target}"
METADATA_FILE="$CARGO_TARGET_DIR/.script-access-times"
RUST_STORE_PATH_CACHE="$CARGO_TARGET_DIR/.rust-store-path"

NIX_EXPR='let rust_flake = builtins.getFlake "github:oxalica/rust-overlay/7ed7e8c74be95906275805db68201e74e9904f07"; nixpkgs_flake = builtins.getFlake "github:NixOS/nixpkgs/f61125a668a320878494449750330ca58b78c557"; pkgs = import nixpkgs_flake { system = builtins.currentSystem; overlays = [rust_flake.overlays.default]; }; in pkgs.rust-bin.nightly."2025-10-10".default.override { extensions = ["rust-src"]; }'

update_access_time() {
	local script_hash
	script_hash=$(echo "$SCRIPT" | md5sum | cut -c1-2)
	local timestamp
	timestamp=$(date +%s)

	mkdir -p "$CARGO_TARGET_DIR"
	touch "$METADATA_FILE"

	# Update or add entry for this script hash
	if grep -q "^$script_hash " "$METADATA_FILE" 2>/dev/null; then
		sed -i "s/^$script_hash .*/$script_hash $timestamp/" "$METADATA_FILE"
	else
		echo "$script_hash $timestamp" >>"$METADATA_FILE"
	fi
}

cleanup_old_caches() {
	local now
	now=$(date +%s)
	local threshold=$((30 * 24 * 60 * 60)) # 30 days in seconds
	local needs_cleanup=false

	[ -f "$METADATA_FILE" ] || return

	while read -r hash timestamp; do
		if ((now - timestamp > threshold)); then
			needs_cleanup=true
			break
		fi
	done <"$METADATA_FILE"

	if $needs_cleanup; then
		(
			# Run cleanup in background
			while read -r hash timestamp; do
				if ((now - timestamp > threshold)); then
					rm -rf "${CARGO_TARGET_DIR:?}/$hash"
					sed -i "/^$hash /d" "$METADATA_FILE"
				fi
			done <"$METADATA_FILE"

			# Mark orphaned directories with timestamp 60 days in future (effective 90d retention)
			local future_timestamp=$((now + 60 * 24 * 60 * 60))
			for dir in "$CARGO_TARGET_DIR"/*/; do
				[ -d "$dir" ] || continue
				local dirname
				dirname=$(basename "$dir")
				[[ "$dirname" =~ ^[0-9a-f]{2}$ ]] || continue
				if ! grep -q "^$dirname " "$METADATA_FILE" 2>/dev/null; then
					echo "$dirname $future_timestamp" >>"$METADATA_FILE"
				fi
			done
		) &>/dev/null &
		disown
	fi
}

# Get rust toolchain store path (cached to avoid 2+ second nix eval overhead)
get_rust_store_path() {
	# Check if we have a cached store path that still exists
	if [ -f "$RUST_STORE_PATH_CACHE" ]; then
		local cached_path
		cached_path=$(cat "$RUST_STORE_PATH_CACHE")
		if [ -d "$cached_path" ]; then
			echo "$cached_path"
			return 0
		fi
	fi

	# Need to resolve the store path (slow, ~2s)
	local store_path
	if store_path=$(nix build --no-link --print-out-paths --offline --impure --expr "$NIX_EXPR" 2>/dev/null); then
		mkdir -p "$CARGO_TARGET_DIR"
		echo "$store_path" >"$RUST_STORE_PATH_CACHE"
		echo "$store_path"
		return 0
	fi

	return 1
}

update_access_time
cleanup_old_caches

# Try to use cached store path for instant startup
if RUST_PATH=$(get_rust_store_path); then
	exec "$RUST_PATH/bin/cargo" -Zscript -q "$SCRIPT" "$@"
fi

# Cache miss - need to fetch
notify-send "nix cache miss, fetching..." -t 3000 2>/dev/null &

# Build and cache the store path, then run
if RUST_PATH=$(nix build --no-link --print-out-paths --impure --expr "$NIX_EXPR" 2>/dev/null); then
	mkdir -p "$CARGO_TARGET_DIR"
	echo "$RUST_PATH" >"$RUST_STORE_PATH_CACHE"
	exec "$RUST_PATH/bin/cargo" -Zscript -q "$SCRIPT" "$@"
fi

# Fallback to nix shell if build fails for some reason
exec nix shell --impure --expr "$NIX_EXPR" --command cargo -Zscript -q "$SCRIPT" "$@"
