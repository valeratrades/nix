#!/usr/bin/env bash
# Wrapper for cargo -Zscript with nix, tries --offline first
# Usage: nix-run-cached <script.rs> [args...]
# Tracks script usage and cleans up old caches (>30 days unused)
# Caches the nix store path to avoid re-evaluating the flake expression every time

SCRIPT="$1"
shift

CARGO_TARGET_DIR="${CARGO_TARGET_DIR:-$HOME/.cargo/target}"
METADATA_FILE="$CARGO_TARGET_DIR/.script-access-times"
RUST_STORE_PATH_CACHE="$CARGO_TARGET_DIR/.rust-store-path"

NIX_EXPR='let rust_flake = builtins.getFlake "github:oxalica/rust-overlay/7ed7e8c74be95906275805db68201e74e9904f07"; nixpkgs_flake = builtins.getFlake "github:NixOS/nixpkgs/f61125a668a320878494449750330ca58b78c557"; pkgs = import nixpkgs_flake { system = builtins.currentSystem; overlays = [rust_flake.overlays.default]; }; in pkgs.rust-bin.nightly."2025-10-10".default.override { extensions = ["rust-src"]; }'

update_access_time() {
	local script_hash
	script_hash=$(echo "$SCRIPT" | md5sum | cut -c1-2)
	local timestamp
	timestamp=$(date +%s)

	mkdir -p "$CARGO_TARGET_DIR"
	touch "$METADATA_FILE"

	# Update or add entry for this script hash
	if grep -q "^$script_hash " "$METADATA_FILE" 2>/dev/null; then
		sed -i "s/^$script_hash .*/$script_hash $timestamp/" "$METADATA_FILE"
	else
		echo "$script_hash $timestamp" >>"$METADATA_FILE"
	fi
}

try_fix_root_owned_dirs() {
	[ "$(id -u)" = "0" ] && return 1

	# Fix any root-owned files/dirs in cargo target (from accidental sudo runs)
	# Cargo's -Zscript hashes script content, not path, so `sudo 2fa` created
	# /home/v/.cargo/target/2b/... as root, blocking normal user builds.
	local root_owned
	root_owned=$(find "$CARGO_TARGET_DIR" -maxdepth 2 -user root 2>/dev/null | head -1)
	[ -z "$root_owned" ] && return 1

	echo "WARN: $root_owned was root-owned, fixing" >&2
	sudo chown -R "$(id -un):$(id -gn)" "$root_owned" 2>/dev/null
}

cleanup_old_caches() {
	local now
	now=$(date +%s)
	local threshold=$((30 * 24 * 60 * 60)) # 30 days in seconds
	local needs_cleanup=false

	[ -f "$METADATA_FILE" ] || return

	while read -r hash timestamp; do
		if ((now - timestamp > threshold)); then
			needs_cleanup=true
			break
		fi
	done <"$METADATA_FILE"

	if $needs_cleanup; then
		(
			# Run cleanup in background
			while read -r hash timestamp; do
				if ((now - timestamp > threshold)); then
					rm -rf "${CARGO_TARGET_DIR:?}/$hash"
					sed -i "/^$hash /d" "$METADATA_FILE"
				fi
			done <"$METADATA_FILE"

			# Mark orphaned directories with timestamp 60 days in future (effective 90d retention)
			local future_timestamp=$((now + 60 * 24 * 60 * 60))
			for dir in "$CARGO_TARGET_DIR"/*/; do
				[ -d "$dir" ] || continue
				local dirname
				dirname=$(basename "$dir")
				[[ "$dirname" =~ ^[0-9a-f]{2}$ ]] || continue
				if ! grep -q "^$dirname " "$METADATA_FILE" 2>/dev/null; then
					echo "$dirname $future_timestamp" >>"$METADATA_FILE"
				fi
			done
		) &>/dev/null &
		disown
	fi
}

# Get rust toolchain store path (cached to avoid 2+ second nix eval overhead)
get_rust_store_path() {
	# Check if we have a cached store path that still exists
	if [ -f "$RUST_STORE_PATH_CACHE" ]; then
		local cached_path
		cached_path=$(cat "$RUST_STORE_PATH_CACHE")
		if [ -d "$cached_path" ]; then
			echo "$cached_path"
			return 0
		fi
	fi

	# Need to resolve the store path (slow, ~2s)
	local store_path
	if store_path=$(nix build --no-link --print-out-paths --offline --impure --expr "$NIX_EXPR" 2>/dev/null); then
		mkdir -p "$CARGO_TARGET_DIR"
		echo "$store_path" >"$RUST_STORE_PATH_CACHE"
		echo "$store_path"
		return 0
	fi

	return 1
}

update_access_time
cleanup_old_caches

run_cargo() {
	env RUSTC_WRAPPER="" PATH="$1/bin:$PATH" "$1/bin/cargo" -Zscript -q "$SCRIPT" "${@:2}"
}

# Try to use cached store path for instant startup
# RUSTC_WRAPPER="" disables sccache from cargo config to avoid version mismatches
# PATH must include the nix rust bin so cargo finds the correct rustc
if RUST_PATH=$(get_rust_store_path); then
	if run_cargo "$RUST_PATH" "$@"; then
		exit 0
	elif try_fix_root_owned_dirs; then
		exec run_cargo "$RUST_PATH" "$@"
	fi
	exit 1
fi

# Cache miss - need to fetch
notify-send "nix cache miss, fetching..." -t 3000 2>/dev/null &

# Build and cache the store path, then run
if RUST_PATH=$(nix build --no-link --print-out-paths --impure --expr "$NIX_EXPR" 2>/dev/null); then
	mkdir -p "$CARGO_TARGET_DIR"
	echo "$RUST_PATH" >"$RUST_STORE_PATH_CACHE"
	if run_cargo "$RUST_PATH" "$@"; then
		exit 0
	elif try_fix_root_owned_dirs; then
		exec run_cargo "$RUST_PATH" "$@"
	fi
	exit 1
fi

# Fallback to nix shell if build fails for some reason
env RUSTC_WRAPPER="" nix shell --impure --expr "$NIX_EXPR" --command cargo -Zscript -q "$SCRIPT" "$@" && exit 0
try_fix_root_owned_dirs && exec env RUSTC_WRAPPER="" nix shell --impure --expr "$NIX_EXPR" --command cargo -Zscript -q "$SCRIPT" "$@"
exit 1
